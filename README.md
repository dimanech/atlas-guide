# Atlas-guide

[![Coverage Status](https://coveralls.io/repos/github/dimanech/atlas-guide/badge.svg?branch=master&servic)](https://coveralls.io/github/dimanech/atlas-guide?branch=master)
[![Maintainability](https://api.codeclimate.com/v1/badges/f37cf365f3315cfc287c/maintainability)](https://codeclimate.com/github/dimanech/atlas-guide/maintainability)
[![Linux build status](https://travis-ci.org/dimanech/atlas-guide.svg?branch=master)](https://travis-ci.org/dimanech/atlas-guide/)
[![Win build status](https://ci.appveyor.com/api/projects/status/xiaw6yi35d527i67/branch/master?svg=true)](https://ci.appveyor.com/project/dimanech/atlas-guide/branch/master)
[![Greenkeeper badge](https://badges.greenkeeper.io/dimanech/atlas-guide.svg)](https://greenkeeper.io/)
[![Known Vulnerabilities](https://snyk.io/test/github/dimanech/atlas-guide/badge.svg?targetFile=package.json)](https://snyk.io/test/github/dimanech/atlas-guide?targetFile=package.json)
[![npm version](https://badge.fury.io/js/atlas-guide.svg)](https://badge.fury.io/js/atlas-guide)

Atlas is living style-guide, pattern library, guidelines and documentation static site generator with extensive
styles monitoring and Sass components reports.

It is opinionated because it is probably impossible to cover all cases in CSS/Sass.
It designed primarily as "Styleguide driven development" tool with focus on split files approach and incapsulated components.

[Live example](https://dimanech.github.io/atlas-guide/)
[Video example](https://youtu.be/Vohb_Xl6S54)

![atlas-component](docs/screens/atlas-component.jpeg)

## Features

* blazing fast thanks to Mustache and Marked. It primary designed as development platform;
* supports incremental builds, so only changed pages could be updated;
* could be setup with live reload or "hot" reload;
* small list of dependencies (Mustache, Marked, PostCSS, CSSStats, ImportsGraph, D3 and Lodash parts);
* all internal templates and styles could be overwritten on project level;
* could be used as simple guide docs generator;
* Hologram compatible (without front matter section);
* standards compatible. If needed all docs sources could be parsed as standard markdown and compiled to standard HTML
to be used in different tool like Dash or other platforms. No incompatible syntax or constructions is used.

### Components library

Support `/*md` comment in `scss` files where regular markdown could be placed.

* comes with simple playground, so code examples could be live-edited, previewed and copy-pasted;
* consists of 3 main types of pages - component, guide and reports and could be expanded to many different types;
* navigation tree copy project tree, to ease of orientation and handling huge components library;
* components tree filtering and folding;
* component statistic:
    * local variables, internal and external dependencies;
    * raw reduced structure;
    * health check;
    * profile;
    * compatibility with declared constants (if they declared);
* autogenerated Styleguide page based on project constants;
* deprecation system.

### Guide

Support regular markdown files in components folders and process it as guideline pages.

* markdown support;
* table of contents and permalinks to sections;
* do/not-do colorized examples.

### Reports

* imports graph;
* cross components dependencies graph;
* sass components files sizes;
* project statistical reports:
    * basic statistics;
    * size:
        * file sizes comparison with raw and gzip;
        * data uri size and used data;
    * selectors and rules:
        * specificity graph and heaviest, longest selectors list;
        * rule set size and heaviest, empty rule sets list;
        * `js-` prefixed selectors, universal selectors, id selectors and important rules lists;
    * project consistency:
        * total vs unique declaration of style and metric properties;
        * unique media queries used.

## Getting started

### Installing

```
npm install atlas-guide
```

### Configuring

`.atlasrc.json`:

```json
{
    "guideSrc": "path/to/scss/",
    "guideDest": "path/to/guide/",
    "cssSrc": "path/to/css/"
}
```

Then in `package.json`

```json
{
  "scripts": {
    "build-atlas": "atlas-guide --build"
  }
}
```

### Writing documentation

In `path/to/scss/style.scss`:

```scss
/*md

# Component name

Component description.

Component example (Add one more backtick to make this example works):

``html_example
<h1>Some</h1>
``
*/

.regular-scss-here {
    margin: 0;
}
```

### Building Atlas

```
npm run build-atlas
```

See example guideline page or this repo gulp to get the idea how live reload and incremental builds could be set upped.

### API

```js
const atlas = require('atlas-guide');
atlas.build().then(...); // build all guide files without reports. Returns promise.
atlas.build('/absolute/path/to/changed/file.scss').then(...); // compile only particular file, if it marked as documented in project tree
atlas.buildAll().then(...); // compile all guide and reports. Returns promise.
```

Use `atlas.build()` for incremental development builds, where it is not required to have extensive heavy-weight statistic.

### CLI

```shell
Usage: atlas-guide [option]

Options:
  --build                    build all atlas pages
  -v, --version              print Atlas-guide version
  --help                     print this message
```

## Configuration

Atlas search configuration in this order:

1. `.atlasrc.json` in project root
2. `atlasConfig` field in `package.json`

### `.atlasrc.json`

By default atlas search for configuration in `.atlasrc.json` file in the root of the project.

Minimal configuration:

```json
{
    "guideSrc": "assets/scss/",
    "guideDest": "guide/",
    "cssSrc": "assets/css/"
}
```

### `atlasConfig` in `package.json`

If you project stores all configurations in `package.json` you probably want to store atlas configuration here also.
To do that add `atlasConfig` field to your `package.json`.

Note: if you have both `.atlasrc.json` and `package.json` -- `.atlasrc.json` will be used.

Minimal configuration:

```json
{
  "name": "some-project",
  "version": "0.0.1",
  "atlasConfig": {
    "guideSrc": "assets/scss/",
    "guideDest": "guide/",
    "cssSrc": "assets/css/"
  }
}
```

### Templates overwrites

As the next step you, probably, want to add your project CSS and JS to render components examples properly.
To make this happen you need to add `partials` to the config, with paths to the templates in your project space:

```json
{
    "partials": {
      "assetshead": "guide/project-head.mustache",
      "assetsfooter": "guide/project-footer.mustache"
    }
}
```

...and add links to your project CSS/JS. Ex: `project-head.mustache`

```html
<link rel="stylesheet" type="text/css" href="../css/project.css"/>
<link rel="stylesheet" type="text/css" href="../css/additional.css"/>
```

`project-footer.mustache`:

```html
<script src="../js/bundle.js"></script>
```

Note, that paths should be related to generated HTML, no matter where templates are stored. This is simple include that
will be incorporated into resulted html.

All templates and partials in Atlas could be overwritten. Please see this repo views folder to get list of all templates
and partials.

### All available configuration options

```json
{
    "guideSrc": "path/to/components/directory/",
    "guideDest": "path/where/atlas/will/be/placed/",
    "cssSrc": "path/to/css/",
    "scssSrc": "path/to/scss/",
    "scssAdditionalImportsArray": "",
    "componentPrefixes": ["b-", "l-"],
    "excludedCssFiles": "dev_",
    "excludedSassFiles": "dev_",
    "excludedDirs": "dev_",
    "copyInternalAssets": true,
    "templates": {
        "about": "",
        "bundle": "",
        "component": "",
        "guide": "",
        "insights": "",
        "styleguide": ""
    },
    "includes": {
        "aside": "",
        "assetsfooter": "",
        "assetshead": "",
        "componentstataside": "",
        "componentstatfooter": "",
        "componentstatstructure": "",
        "copyright": "",
        "footer": "",
        "header": "",
        "logo": "",
        "navigation": "",
        "toc": "",
        "welcome": ""
    },
    "projectConstants": {
        "constantsSrc": "path/to/project-settings.scss",
        "colorPrefix": "color",
        "fontPrefix": "font",
        "scalePrefix": "scale",
        "spacePrefix": "space",
        "motionPrefix": "motion",
        "depthPrefix": "depth",
        "breakpointPrefix": "break"
    }
}
```

`scssSrc` is optional. It should be used if `guideSrc` is different from scss root. If not defined â€“ `guideSrc` will be used.
Proper path to root scss files needed to generate dependencies graph.

## Usage

Atlas like Vim consists of two functions - beeping and corrupting files. But with minor difference.
It generate guide and generate reports. You need to document code to make it "beeping" and provide config to make it
generate files.

In this section we need to cover 2 topics - documenting and reports configuration.

### Documenting code

#### Doc comment

Add this comment to the scss file and it file appears as component page.

```scss
/*md

# Component name

 */
```

Inside this comment regular markdown syntax would used, so any valid markdown will work here.

```scss
/*md

# Heading level 1

## Heading level 2

## Heading level 3

Regular paragraph with **bold**, _italic_ and `inline code`.

* list item
* list item
* list item

1. ordered list item
2. ordered list item
3. ordered list item

etc.

 */
```

Note: Please avoid some tricky markdown construction, because `marked` super fast, but with this comes not great smartness.

#### Component example

Atlas extends markdown code block "fences" notation with custom type (just like Hologram) -- `html_example`.
That render component playground instead of code-example. This keeps documentation compatible with regular markdown.

To create component example you need to add code-block with `html_example`:

```scss
/*md

``html_example
<h1>Add one more backtick to make this example works</h1>
``

*/
```

#### Regular code blocks

Simple `html`, `scss`, `css` "fences" become regular code-block:

```scss
/*md

``html
<h1>heading 1</h1>
``

``scss
.some { maring: 0; }
``

*/
```

#### Styling code "fences"

All "_" in code block "fences" will be removed, but original "fence" will be added as CSS-class, so you could
use it to style code by your needs. Atlas by default style 2 class `*_bad`, `*_good`. This could be used in guidelines.

```md
``html_bad
<H1>not do</H1>
``

``html_good
<h1>do</h1>
``
```

#### Template helpers

To inline some resources like svg icons, inlined styles etc. you could use `inline` helper. Ex:

```html
{{#inline}}assets/src/images/icons.svg{{/inline}}
```

This helper use path to file from your project root. Virtually any file could be inlined.

### Guideline/Documentation page

Simply put regular markdown file to components tree and they automatically become part of the atlas.

### Build guide and reports

#### Incremental builds

Regular development flow could be organized like this â€“ build all guide pages on start and incrementally rebuild pages on file changes:

```js
const atlas = require('atlas-guide');
atlas.build().then(...); // build all guide files without reports

// watch for changes, get changed file path and build needed page:
atlas.build('/absolute/path/to/changed/file.scss').then(...); // compile only this file if was documented on module import
```

##### Gulp example

See example guideline page or this repo `gulpfile.js` to get the idea how live reload and incremental builds could be set upped.

#### Complete Atlas generation

Due to time efforts reports not generated in regular flow. To generate reports you need to call `npm atlas-guide --build-all`
or in JS:

```js
const atlas = require('atlas-guide');
atlas.buildAll().then(...); // compile all components, guidelines and reports
```

### Autogenerated styleguide based on project constants

Atlas could automatically generate (styleguide page)[https://dimanech.github.io/atlas-guide/styleguide.html] and warn if this constants not used in (component statistic)[https://dimanech.github.io/atlas-guide/bindings-frame-b-atlas-component.html#h2-component-footer]
if project constants is setup.

#### Setup constants

This set up could be a tricky part, because it required full sass compilation and has some limitations.

First you need to use constants in simple form. Ex:

```scss
$color-violet: #594199;
$color-fuchsia: #bc1f8c;

$scale-sm: 0.8rem;
$scale-md: 1rem;
```

No lists, maps or functions that do some thing with it not supported.

Second. If you use additional import array in sass, please, add it to config first `"scssAdditionalImportsArray": ["path/to/additional/sass/files"]`.

Other steps should be simple:

* add path to constants manifest file
* add prefixes that is used for different types of constants

```json
{
    "guideSrc": "path/to/components/directory/",
    "guideDest": "path/where/atlas/will/be/placed/",
    "cssSrc": "path/to/css/",
    "scssSrc": "path/to/scss/",
    "scssAdditionalImportsArray": ["path/to/additional/sass/files"],
    "projectConstants": {
        "constantsSrc": "path/to/project-settings.scss",
        "colorPrefix": "color",
        "fontPrefix": "font",
        "scalePrefix": "scale",
        "spacePrefix": "space",
        "motionPrefix": "motion",
        "depthPrefix": "depth",
        "breakpointPrefix": "break"
    }
}
```

After that styleguide page and components stat hints would be generated beside components regular building cycle.

## Troubleshooting

### I need to remove unneeded graphs, info, features etc. How to do this?

The most robust way to do this is extend templates on project level and remove views that responsible for that.

### I build dependency graph but it has too much duplicate imports since each our resulted file include the same files.

To clean up the graph you could add duplicated files into scss ignore list. To do this put regexp to `excludedSassFiles` field.

## Contributing

You are welcome for ideas, help and of course code contributing.

We have git hooks with all validation. Please install it manually on first time by run `npm run copyhooks`.

## License

Copyright Â© 2018, D. Nechepurenko. Published under MIT license.
